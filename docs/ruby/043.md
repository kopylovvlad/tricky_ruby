# Decorators for methods

Ruby compiler allows us to run a method before a function definition. For example we can use the feature for using decorators.

```ruby
# Name space for decorator
module Decorated
  # Decorates method and converts the value to an integer
  def integer(method_name)
    alias_method "original_#{method_name}", method_name

    define_method method_name do
      send("original_#{method_name}").to_i
    end
  end

  # Decorates method and converts the value to a string
  def string(method_name)
    alias_method "original_#{method_name}", method_name

    define_method method_name do
      send("original_#{method_name}").to_s
    end
  end
end
```

Then we can easily add the namespace to any class.

```ruby
class A
  extend Decorated

  integer def get_float
    0.0
  end

  string def get_integer
    12
  end
end

a = A.new
puts a.get_float
# 0
puts a.original_get_float
# 0.0
puts a.get_integer.class
# String
puts a.original_get_integer.class
# Integer
```

How can we use it? For example to write contracts.

```ruby
# The namespace for contracts
module Contracted
  def sign(method_name, *data_types)
    alias_method "original_#{method_name}", method_name

    define_method method_name do |*args|
      data_types.each_with_index do |klass, index|
        param = args[index]
        next if param.is_a?(klass)
        raise "Param##{index} (#{param}) is not a instance of #{klass}"
      end
      send("original_#{method_name}", *args)
    end
  end
end


class A
  extend Contracted

  sign def say_hi(name)
    puts "Hi, #{name}!"
  end, String
end

a = A.new
a.say_hi("John")
# Hi, John!
a.say_hi(123)
# Param#0 (123) is not a instance of String (RuntimeError)
```

One more example

```ruby
class A
  extend Contracted

  sign def sum(a, b)
    a + b
  end, Integer, Integer
end

a = A.new
puts a.sum(10, 22)
# 32
puts a.sum(10, '22')
# Param#1 (22) is not a instance of Integer (RuntimeError)

```
